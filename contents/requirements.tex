\newcolumntype{L}{>{\centering\arraybackslash}m{5cm}}
\newcolumntype{S}{>{\centering\arraybackslash}m{35mm}}
\newcommand\setrow[1]{\gdef\rowmac{#1}#1\ignorespaces}
            
\section{Software Requirements}
    This section discusses the software requirements and explains the rationale behind them. First subsection talks about software requirements, while in the second subsection hardware components and running of software requirements are explained.

    \subsection{Product Functions}
        Firstly, \autoref{table:coreproductfunc} presents core functions that the software has to be able to perform. Each of the core functionalities are explained in more detail later on.
        
        \begin{table}[!htbp]
            \centering
            \caption{Core Product Functions}
            \begin{tabular}{@{}|>{\columncolor[HTML]{DDDDDD}}c |c|c|@{}}
                \toprule
                \textbf{Function} & \cellcolor[HTML]{DDDDDD}\textbf{Description} & \cellcolor[HTML]{DDDDDD}\textbf{Priority Level} \\ \midrule
                {\color[HTML]{000000} \textbf{1}} & Download LSTM Data Sets & Medium \\ \midrule
                {\color[HTML]{000000} \textbf{2}} & Data Mine Tweets & High \\ \midrule
                {\color[HTML]{000000} \textbf{3}} & Develop LSTM Neural Network & High \\ \midrule
                \textbf{4} & \begin{tabular}[c]{@{}c@{}}Build a Graph Representation \\ of LSTM Predictions\end{tabular} & High \\ \midrule
                \textbf{5} & \begin{tabular}[c]{@{}c@{}}Perform Bipolar Argumentation \\ Framework Analysis\end{tabular} & High \\ \bottomrule
            \end{tabular}
            \label{table:coreproductfunc}
        \end{table}
        
        Each function has a priority level attached to it. High priority represents a necessity, a functionality that is expected to be a part of the minimum viable product. Medium priority describes a case where the functionality is not critical, but provides a useful addition to overall performance of the software. Low priority is generally a nice-to-have, focusing on ease of software use, intermittent result saving for additional future analysis or user experience, e.g. informing the user of currently performed actions or steps.
        
        \subsubsection{LSTM Data Download Requirements}
            Requirements for Automating the download of required data either for processing or \gls{lstm} training are described here (\autoref{table:func1spec}.
            
            \begin{table}[!htbp]
                \centering
                \caption{Function 1 Specifics}
                \begin{tabular}{@{}|>{\columncolor[HTML]{DDDDDD}}c |c|c|@{}}
                    \toprule
                    \textbf{Function} & \cellcolor[HTML]{DDDDDD}\textbf{Description} & \cellcolor[HTML]{DDDDDD}\textbf{Priority Level} \\ \midrule
                    {\color[HTML]{000000} \textbf{1.1}} & Download GloVe Vector Data & High \\ \midrule
                    {\color[HTML]{000000} \textbf{1.2}} & \begin{tabular}[c]{@{}c@{}}Download Stanford Natural\\ Language Inference Data\end{tabular} & Low \\ \midrule
                    {\color[HTML]{000000} \textbf{1.3}} & Extract/Unzip Downloaded Data & Medium \\ \bottomrule
                \end{tabular}
                \label{table:func1spec}
            \end{table}
                
            \gls{glove} data is on high priority because it describes how sentences consisting of words and characters are to be transformed into numerical multidimensional arrays for \gls{lstm} processing. This is required for use with Twitter data and \gls{lstm} training, validation and testing purposes as well.
            
            On the other hand, \gls{snli} data is only used for training and testing of \gls{lstm}. Because training of the model is done beforehand, the user would not need to worry about this unless the goal is to train a different \gls{lstm} model (and use it).
            
            Requirements presented here will be evaluated via programmed test case checking for whether specified file names exist in a directory.
            
        \subsubsection{Twitter Data Mining Requirements}
            Specific functional requirements for Data Mining on Twitter are presented here. The \autoref{table:func2spec} lists what is meant by "Data Mining" and what processes it involves.
            
            \begin{table}[!h]
                \centering
                \caption{Function 2 Specifics}
                \begin{tabular}{@{}|>{\columncolor[HTML]{DDDDDD}}c |c|c|@{}}
                    \toprule
                    \textbf{Function} & \cellcolor[HTML]{DDDDDD}\textbf{Description} & \cellcolor[HTML]{DDDDDD} \textbf{Priority Level} \\ \midrule
                    {\color[HTML]{000000} \textbf{2.1}} & Input Search Term or Topic to Mine & High \\ \midrule
                    {\color[HTML]{000000} \textbf{2.2}} & Save Data Mined Tweets into .csv File & Medium \\ \midrule
                    {\color[HTML]{000000} \textbf{2.3}} & Remove Non-Alphanumerical Characters & High \\ \midrule
                    {\color[HTML]{000000} \textbf{2.4}} & Remove Stop Words & High \\ \midrule
                    {\color[HTML]{000000} \textbf{2.5}} & Lemmatize words & High \\ \midrule
                    {\color[HTML]{000000} \textbf{2.6}} & Remove Duplicate Tweets & High \\ \midrule
                    {\color[HTML]{000000} \textbf{2.7}} & Filter Short Tweets & Low \\ \midrule
                    {\color[HTML]{000000} \textbf{2.8}} & Read Tweets from Saved .csv File & Medium \\ \bottomrule
                \end{tabular}
                \label{table:func2spec}
            \end{table}
            
            The requirements here are mostly concerned with cleaning the mined data. This involves removal of non-alphanumerical characters, such as twitter hashtags (\#), links to other websites, mentions of other users (\@), as well as the removal of stop words, duplicate or too short (e.g. single word) tweets, performing lemmatization.
            
            To ensure that the functionalities described in the table above work as intended, test cases will be developed. Some requirements might be assessed together in a single test case, as they are closely related (e.g. 2.2 and 2.8).
        
        \subsubsection{LSTM Development Requirements}
            \gls{lstm} is the core of this software, because it serves the most important task of accurately predicting argument relations and directions, thus all of its' functional requirements are in high priority.
            
            \begin{table}[!htbp]
                \centering
                \caption{LSTM Development Specifics}
                \begin{tabular}{@{}|>{\columncolor[HTML]{DDDDDD}}c |c|c|@{}}
                    \toprule
                    \textbf{Function} & \cellcolor[HTML]{DDDDDD}\textbf{Description} & \cellcolor[HTML]{DDDDDD}\textbf{Priority Level} \\ \midrule
                    {\color[HTML]{000000} \textbf{3.1}} & Process GloVe Vector Data & High \\ \midrule
                    {\color[HTML]{000000} \textbf{3.2}} & Perform LSTM Training & High \\ \midrule
                    {\color[HTML]{000000} \textbf{3.3}} & Perform LSTM Validation & High \\ \midrule
                    \textbf{3.4} & Perform LSTM Testing & High \\ \midrule
                    \textbf{3.5} & Perform LSTM Prediction on Tweets & High \\ \midrule
                    \textbf{3.6} & Perform With 75\% Accuracy Or More & High \\ \midrule
                    \textbf{3.7} & Save Successfully Trained LSTM Model & High \\ \midrule
                    \textbf{3.8} & Load Existing Specified LSTM Model & High \\ \bottomrule
                \end{tabular}
                \label{table:func3spec}
            \end{table}
            
            Evaluation of \gls{lstm} requirements is going to be a little bit different than the others. For the 3.2, 3.3, 3.4 and 3.6 functionality, information about real time performance (accuracy and loss values) is being logged and saved. So to make sure that the requirements are fulfilled, a simple check of these logs will be performed and evaluated that way. To test the remaining requirements, specific test cases will be developed and run.
        
        \subsubsection{Graph Network Requirements}
            The Graph is one of the main ways to represent argument frameworks and analyse them. The requirements are listed in \autoref{table:func4spec}.
            
            \begin{table}[!htbp]
                \centering
                \caption{Graph Network Specifics}
                \begin{tabular}{@{}|>{\columncolor[HTML]{DDDDDD}}c |c|c|@{}}
                    \toprule
                    \textbf{Function} & \cellcolor[HTML]{DDDDDD}\textbf{Description} & \cellcolor[HTML]{DDDDDD}\textbf{Priority Level} \\ \midrule
                    {\color[HTML]{000000} \textbf{4.1}} & Create a Node for Each Argument & High \\ \midrule
                    {\color[HTML]{000000} \textbf{4.2}} & Create an Edge for Each Argument Relation & High \\ \midrule
                    {\color[HTML]{000000} \textbf{4.3}} & Differentiate Attack and Support Edges & High \\ \midrule
                    \textbf{4.4} & Save Graph Data into .gexf File & Low \\ \midrule
                    \textbf{4.5} & Load Graph Data from .gexf File & Low \\ \midrule
                    \textbf{4.6} & Display Computed Directed Graph & Low \\ \bottomrule
                \end{tabular}
                \label{table:func4spec}
            \end{table}
            
            Each vertex represents an argument, and an edge - relation between those arguments. The resulting graph must be Digraph, with different edges for \textit{attack} and \textit{support} relations.
            
            All of the requirements listed here will be evaluated with test cases.
        
        \subsubsection{Argument Framework Analysis Requirements}
            The requirements for \gls{af} analysis state steps that need to be taken in order to compute the grounded extensions of argument graphs.
            
            \begin{table}[!htbp]
                \centering
                \caption{Function 5 Specifics}
                \begin{tabular}{@{}|>{\columncolor[HTML]{DDDDDD}}c |c|c|@{}}
                    \toprule
                    \textbf{Function} & \cellcolor[HTML]{DDDDDD}\textbf{Description} & \cellcolor[HTML]{DDDDDD}\textbf{Priority Level} \\ \midrule
                    {\color[HTML]{000000} \textbf{5.1}} & Compute Conflict Free Arguments & High \\ \midrule
                    {\color[HTML]{000000} \textbf{5.2}} & Compute Admissible Arguments & High \\ \midrule
                    {\color[HTML]{000000} \textbf{5.3}} & Compute the Grounded Extension Arguments & High \\ \midrule
                    \textbf{5.4} & Print to Console the Grounded Extension & Medium \\ \midrule
                    \textbf{5.5} & Supported Size At Least 15 Arguments & Medium \\ \midrule
                    \textbf{5.6} & Full Analysis Should Take No Longer Than 15 Seconds & Medium \\ \midrule
                    \textbf{5.7} & ??????????????????????????????????????????????? & Medium \\ \bottomrule
                \end{tabular}
                \label{table:func5spec}
            \end{table}
            
            This part of software is also very important, because argument frameworks are what is used to analyze argumentation in \gls{ai}. Thus, high priority levels for each computational requirement listed in \autoref{table:func5spec} are in line with the goal of the project.
            
            Requirements listed here are sequential, meaning that in order to fulfil 5.3 requirement, 5.2 needs to be computed first. For evaluation, a test case will be developed containing couple or more text book examples. The answers provided in these examples will be compared to those that the system outputs. This will ensure that the software is capable of working at a baseline level.
        
    \subsection{Operating Environment}
        This section describes the hardware and system requirements that the software must be able to run on. These requirements are important because not every hardware is going to be able to handle the same amounts of data or in the same amount of time.
        
        \begin{table}[!htbp]
            \centering
            \caption{Operating Environment}
            \begin{tabular}{@{}|>{\columncolor[HTML]{DDDDDD}}c |c|c|@{}}
                \toprule
                \textbf{Hardware/System} & \cellcolor[HTML]{DDDDDD}\textbf{Description} & \cellcolor[HTML]{DDDDDD}\textbf{Value} \\ \midrule
                {\color[HTML]{000000} \textbf{\begin{tabular}[c]{@{}c@{}}Central Processing\\ Unit\end{tabular}}} & \begin{tabular}[c]{@{}c@{}}Responsible for running applications\\ and performing calculations\end{tabular} & \begin{tabular}[c]{@{}c@{}}Intel i7-7700k\\ @4.2GHz\end{tabular} \\ \midrule
                {\color[HTML]{000000} \textbf{\begin{tabular}[c]{@{}c@{}}Rapid Access \\ Memory\end{tabular}}} & \begin{tabular}[c]{@{}c@{}}Responsible for storing data that is\\ currently in use by the Central Processing Unit\end{tabular} & 16.0 GB \\ \midrule
                {\color[HTML]{000000} \textbf{\begin{tabular}[c]{@{}c@{}}Graphics Processing\\ Unit\end{tabular}}} & \begin{tabular}[c]{@{}c@{}}Draws graphics. LSTM component of\\ this software is run on this part as well.\end{tabular} & \begin{tabular}[c]{@{}c@{}}NVIDIA\\ 1080Ti\\ GTX\end{tabular} \\ \midrule
                \textbf{\begin{tabular}[c]{@{}c@{}}Video Rapid\\ Access Memory\end{tabular}} & \begin{tabular}[c]{@{}c@{}}Same as Rapid Access Memory,\\ except used by Graphics Processing Unit\end{tabular} & 11.0 GB \\ \midrule
                \textbf{Operating System} & \begin{tabular}[c]{@{}c@{}}System that performs communications\\ between software and hardware layers\end{tabular} & Windows 10 \\ \bottomrule
            \end{tabular}
            \label{table:operenvironment}
        \end{table}
        \FloatBarrier
        
        Hardware and system specifications listen in \autoref{table:operenvironment} are in line with the development environment, where the software of this project was programmed to run. The purpose here is to guarantee that when the project is complete and requirements are fulfilled, the software runs without issues on the operating environment that it was developed in the first place. These requirements can be interpreted as being "recommended" to run the software optimally. The minimum hardware requirements are outside of the project's scope and are not discussed.
        
        The next chapter discusses decisions with regards to design of the software and possible constraints or dependencies that come with it.